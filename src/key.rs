use crate::base64;
use crate::error::TorError;
use base32::{self, Alphabet};
use ed25519_dalek::{hazmat::ExpandedSecretKey, VerifyingKey};
use rsa::pkcs1::DecodeRsaPrivateKey;
use rsa::pkcs1::EncodeRsaPrivateKey;
use rsa::pkcs1::EncodeRsaPublicKey;
use rsa::{RsaPrivateKey, RsaPublicKey};
use sha1::Sha1;
use sha3::{Digest, Sha3_256};

pub enum PrivateKey {
    RSA1024(RsaPrivateKey),
    ED25519V3 {
        // Note: Have to cache the scalar returned by tor, because it ends up being different
        // than the scalar generated by dalek - the latter adds an additional reduce step
        tor_scalar: Vec<u8>,

        // Note that Tor doesn't give us the secret key (i.e., the original 32-byte random number),
        // instead, it gives us the secret key after it's hashed, which is the "ExpandedSecretKey"
        // in ed25519_dalek
        expanded_secret_key: ExpandedSecretKey,

        // We can generate the VerifyingKey from the ExpandedSecretKey
        verifying_key: VerifyingKey,
    },
}

impl PrivateKey {
    pub fn to_blob(&self) -> String {
        match self {
            Self::RSA1024(key) => base64::encode(key.to_pkcs1_der().unwrap().as_bytes()),
            Self::ED25519V3 {
                tor_scalar,
                expanded_secret_key,
                verifying_key: _,
            } => base64::encode(
                &[tor_scalar.clone(), expanded_secret_key.hash_prefix.to_vec()].concat(),
            ),
        }
    }

    pub fn from_blob(key_type: &str, blob: &str) -> Result<Self, TorError> {
        match key_type {
            "RSA1024" => Ok(Self::RSA1024(
                RsaPrivateKey::from_pkcs1_der(&base64::decode(blob).unwrap()).unwrap(),
            )),
            "ED25519-V3" => {
                let blob = base64::decode(blob).unwrap();
                let expanded_secret_key =
                    ExpandedSecretKey::from_bytes(&blob.clone().try_into().unwrap());
                let verifying_key = VerifyingKey::from(&expanded_secret_key);
                let tor_scalar = Vec::from(&blob[..32]);
                Ok(Self::ED25519V3 {
                    tor_scalar,
                    expanded_secret_key,
                    verifying_key,
                })
            }
            _ => Err(TorError::protocol_error(&format!(
                "Unknown KeyType parameter from server: '{}'",
                key_type
            ))),
        }
    }

    pub fn public_key(&self) -> PublicKey {
        match self {
            PrivateKey::RSA1024(private_key) => PublicKey::RSA1024(private_key.to_public_key()),
            PrivateKey::ED25519V3 {
                tor_scalar: _,
                expanded_secret_key: _,
                verifying_key,
            } => PublicKey::ED25519V3(*verifying_key),
        }
    }
}

#[derive(Clone, Debug)]
pub enum PublicKey {
    RSA1024(RsaPublicKey),
    ED25519V3(VerifyingKey),
}

impl PublicKey {
    pub fn to_vec(&self) -> Result<Vec<u8>, anyhow::Error> {
        match self {
            PublicKey::RSA1024(rsa_public_key) => Ok(rsa_public_key.to_pkcs1_der()?.to_vec()),
            PublicKey::ED25519V3(ed25519_public_key) => Ok(ed25519_public_key.as_bytes().to_vec()),
        }
    }

    pub fn service_id(&self) -> Result<String, anyhow::Error> {
        match self {
            PublicKey::RSA1024(rsa_public_key) => {
                let pkcs1 = rsa_public_key.to_pkcs1_der()?;
                let mut hasher = Sha1::new();
                hasher.update(pkcs1.as_bytes());
                Ok(base32::encode(
                    Alphabet::RFC4648 { padding: false },
                    &hasher.finalize()[..10],
                ))
            }
            PublicKey::ED25519V3(ed25519_public_key) => {
                let version = &[3u8];
                let public_key_bytes = ed25519_public_key.as_bytes().to_vec();
                let mut checksum_bytes = ".onion checksum".as_bytes().to_vec();
                checksum_bytes.extend_from_slice(&public_key_bytes);
                checksum_bytes.extend_from_slice(version);
                let mut hasher = Sha3_256::new();
                hasher.update(&checksum_bytes);
                let checksum: Vec<u8> = hasher.finalize()[..2].to_vec();
                let mut onion_bytes = public_key_bytes;
                onion_bytes.extend_from_slice(&checksum);
                onion_bytes.extend_from_slice(&[3u8]);
                Ok(
                    base32::encode(Alphabet::RFC4648 { padding: false }, &onion_bytes)
                        .to_lowercase(),
                )
            }
        }
    }
}

pub enum KeyRequest<'a> {
    RSA1024,
    ED25519V3,
    Best,
    PrivateKey(&'a PrivateKey),
}

impl<'a> KeyRequest<'a> {
    pub fn rsa1024() -> Self {
        Self::RSA1024
    }

    pub fn ed25519() -> Self {
        Self::ED25519V3
    }

    pub fn best() -> Self {
        Self::Best
    }

    pub fn private_key(key: &'a PrivateKey) -> Self {
        Self::PrivateKey(key)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use hex;

    // Private key is (base64) 0H/jnBeWzMoU1MGNRQPnmd8JqlpTNS3UeTiDOMyPTGGXXpLd0KinCtQbcgz2fCYjbzfK3ElJ7x3zGCkB1fAtAA==
    // Service id is vvqbbaknxi6w44t6rplzh7nmesfzw3rjujdijpqsu5xl3nhlkdscgqad
    #[test]
    fn test_ed25519v3_service_id() -> Result<(), anyhow::Error> {
        let base64_blob = "0H/jnBeWzMoU1MGNRQPnmd8JqlpTNS3UeTiDOMyPTGGXXpLd0KinCtQbcgz2fCYjbzfK3ElJ7x3zGCkB1fAtAA==";
        let private_key = PrivateKey::from_blob("ED25519-V3", base64_blob)?;
        let public_key = private_key.public_key();
        assert_eq!(
            "vvqbbaknxi6w44t6rplzh7nmesfzw3rjujdijpqsu5xl3nhlkdscgqad",
            public_key.service_id()?
        );
        Ok(())
    }

    #[test]
    fn test_to_from_blob() -> Result<(), anyhow::Error> {
        let blob_in = "0H/jnBeWzMoU1MGNRQPnmd8JqlpTNS3UeTiDOMyPTGGXXpLd0KinCtQbcgz2fCYjbzfK3ElJ7x3zGCkB1fAtAA==";
        println!(
            "blob_in = {}",
            hex::encode(base64::decode(blob_in).unwrap())
        );
        let private_key = PrivateKey::from_blob("ED25519-V3", blob_in)?;
        let blob_out = private_key.to_blob();
        println!(
            "blob_out = {}",
            hex::encode(base64::decode(&blob_out).unwrap())
        );
        assert_eq!(blob_in, blob_out);

        Ok(())
    }
}
